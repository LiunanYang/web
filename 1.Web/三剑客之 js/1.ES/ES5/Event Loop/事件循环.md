# JS 单线程，怎么执行异步代码？

JS 引擎执行异步代码而不用等待，是因为有**消息队列**和**事件循环**。

- 消息队列：是一个先进先出的队列，里面存放着各种消息。
  - 消息队列中存放的消息，我们可以认为是**注册异步任务时添加的回调函数**。

- 事件循环：指主线程重复从消息队列中取消息，执行的过程

*事件循环机制详解*：

实际上，主线程只会做一件事情，就是从消息队列中取消息、执行消息，再取消息，再执行。当消息队列为空时，就会等待，直到消息队列变成非空。而主线程只有将当前的消息处理完后，才会去取下一个消息。

*一次循环*：取一次消息并执行的过程。

*用代码表示事件循环*：
```
while(true){
  var message = queue.get()
  execute(message)
}
```
🌰：以异步 AJAX 为例，假设存在如下代码
```
$.ajax('http://www.baidu.com',function(res){
  console.log("收到响应"，res)
})
```
主线程在发起 ajax 请求后，会继续执行其他代码。ajax 线程负责请求baidu.com，拿到响应后，它会把响应封装成一个 JS 对象，然后构造一条消息。
```
<!-- 消息队列中的消息就长这个样子 -->
var message = function(){
  callbackFn(res)
}
```
callbackFn就是前面代码中得到成功响应时的回调函数。

主线程在执行完当前循环中的所有代码后，就会从消息队列中取出这条消息，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也得到执行。如果一开始主线程没有提供回调函数，ajax 在收到 HTTP 响应后，也没必要通知主线程，从而也没有必要往消息队列中放消息。

我们可以得出结论：

**异步过程的回调函数，一定不在当前这一轮事件循环中执行！！！**

浏览器为了使 JS 内部 task 与 DOM 有序执行，会在一个 task 执行完毕，在下一次 task 开始之前，对页面进行重新渲染。

**在一个 macrotask 执行完后，会将在它执行期间产生的 microtask 都执行完毕(在渲染前)**

JS分为同步任务、异步任务
- 同步任务：立即执行的代码，比如一个简单输出
- 异步任务：分为宏任务和微任务
### **宏任务 and 微任务**
- **宏任务 macrotask(task)**:每次执行栈执行的代码就是一个宏任务，包括每次从事件队列中获取一个事件回调并放到执行栈中执行。
  - 主代码块、setTimeout、setInterval、setImmediate、requestAnimalFrame、I/O、UI 渲染

- **微任务 microtask(jobs)**:在当前宏任务执行结束后立即执行的任务。
  - Promise，process.nextTick, Object.observe, MutationObserver


---
测试题
```js
// 1.
for(var i=0;i<5;i++){
  setTimeout(()=>{console.log(i)},1000)
}

// 2.
console.log(a)
console.log(b)
let a = 10
console.log(a)
a = function f(){}
console.log(a)
var b = 30
console.log(b)

// 3.
let length = 10
function fn(){
  console.log(this.length)
}
let obj = {
  length:5,
  method(fn){
    console.log(this.length)
    fn()
    arguments[0]()
  }
}
obj.method(fn,1)
  
// 4.
setTimeout(()=>{
  console.log('set1')
  new Promise(function (resolve){
    resolve()
  }).then(function(){
    new Promise(function(resolve){
      resolve()
    }).then(function(){
      console.log('then4')
    })
    console.log('then2')
  })
})
new Promise(function(resolve){
  console.log('pr1')
  resolve()
}).then(function(){
  console.log('then1')
})
setTimeout(function(){
  console.log('set2')
})
console.log(2)
new Promise(function(resolve){
  resolve()
}).then(function(){
  console.log('then3')
})
```

