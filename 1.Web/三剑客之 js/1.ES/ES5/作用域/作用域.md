# 作用域
- 在JavaScript中，作用域是执行代码的上下文，指一个变量的作用范围

Q: 怎么改变函数的作用域？
A: 实际问的也就是怎么改变函数this指向，移步this篇查看

## 作用域的工作模式
第一种是词法作用域，第二种是动态作用域

区别：
- 词法作用域是在定义的时候确定的，关注函数在何处声明。
- 动态作用域是在运行时确定的，关注函数从何处调用。this机制某种程度上很像动态作用域。

JavaScript 只有词法作用域，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定

假设JavaScript中是动态作用域，下面会输出3（和this一样，谁调用我，我就指向谁）
```js
function foo() {
  console.log(a);
}
function bar() {
  var a = 3;
  foo();
}
var a = 2;
bar(); // a = 2
```

## 分类
### 1.全局作用域
在代码中任何地方都能访问到全局作用域

- 全局作用域在页面打开时创建，在页面关闭时销毁
- 在全局作用域中有一个全局对象window，创建的变量都会作为window对象的属性保存，创建的函数都会作为window的方法保存
- 全局作用域中的变量都是全局变量，在页面的任意部分都可以访问到

以下几种情况为全局作用域
1. 最外层函数和在最外层函数外面定义的变量拥有全局作用域
2. 所有末定义直接赋值的变量自动声明在全局作用域
3. 直接编写在script标签中的JS代码，都在全局作用域

### 2.函数作用域
变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的

- 调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁；
- 每调用一次函数就会创建一个新的函数作用域，他们之间相互独立
- 在函数作用域中，可以访问到全局变量，在全局作用域中，无法访问到函数作用域
- 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接用，如果没有则向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有找到，则 会报错ReferenceError
- 在函数作用域中，也存在变量声明提前
#### 函数声明提前
> 使用函数声明形式创建的函数 function（）{}  ，它会在所有代码在执行之前就被创建，所以我们可以在函数声明前调用函数；

> 使用函数表达式创建的函数 var fun = function（）{} ，不会被提前声明，所以不能在声明前调用

### 3.块级/局部作用域
只在固定的代码片内可以访问到，在外部无法访问
在ES6之前没有块级作用域，ES6 的 let、const 关键字形成块级作用域

好处:
- 避免过多全局变量和函数产生的命名冲突
- 避免循环变量泄露为全局变量
- 避免内层变量覆盖外层变量

Q：为什么会是这样的输出？
A：`var i = 0` 暴露在全局作用域中，因为 setTimeout 有滞后性（只要是 setTimeout 就把其中的函数塞入宏任务中），所以先执行完 for 循环，因为 i 是全局变量，所以 setTimeout 中的 i 统一为 5。
解决：在 ES6 之前，将 for 循环中的函数改成立即执行函数（形成作用域），每次循环，IIFE 就会生成一个新的作用域，使得延迟函数的调回可以将新的作用域封闭在每个循环内部，每个迭代中都会含有一个具有正确值的变量供我们访问。
```js
for (var i = 0; i < 5; i++) {
  setTimeout(function () {
      console.log(i); // 5 5 5 5 5 
  });
}
```