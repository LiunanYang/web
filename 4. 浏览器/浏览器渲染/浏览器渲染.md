# 浏览器渲染
过程：
1. 解析HTML，生成 DOM 树（包含不可见节点），解析 CSS ，生成 CSSOM 树
2. 从 DOM 的根节点开始遍历每个可见节点，对于可见的节点，找到 CSSOM 树中对应的规则，并应用他们，根据每个可见节点及其对应的样式，组合生成渲染树（只包含可见节点）
3. Layout 回流：根据生成的渲染树，进行回流，得到节点的几何信息(位置，大小)，盒模型
4. Painting 重绘：根据渲染树以及回流得到的几何信息，得到节点的几何像素。
5. Display：将像素发给GPU，展示在页面上。

不可见节点：
- 不会渲染输出的节点：script、meta、link
- 通过 CSS 进行隐藏的节点，display:none

> 渲染树：文档流

渲染过程中资源加载与解析关系：
1. html 和 css 的加载和解析是异步的，不会互相干扰
- 只有等 dom 树和 cssom 树构建完成，生成渲染树后，页面才开始渲染，所以 css 加载不会影响 dom 解析，但是会影响 dom 渲染。
2. js 阻塞 dom 树解析
- 代码执行时，遇到 script 标签，浏览器会停止 dom 的解析，等该 js 文件加载并执行后，才继续往下解析。因为 js 可以直接修改 dom，避免出现不可预测的错误。推荐 js 放在最后加载。
3. css 阻塞 js 解析
- 从 head 开始解析，遇到 link 标签，浏览器去加载 css，并且继续往下解析，遇到 js 的话不会去加载，会停下来等css 加载完之后再开始执行，js 没有解析，阻塞了 dom 解析
- 因为 js 可能会修改 DOM 树或 CSSOM 树，如果 js 在 css未加载完时执行，基于不完整的样式信息去操作，会出现错误。

## 浏览器的渲染进程的线程总共有五种
1. **GUI渲染线程**
负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或由于某种操作引发回流时，该线程就会执行。

注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

2. **JS引擎线程**
JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；

注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。

3. **事件触发线程**
时间触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；

注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；
4. **定时器触发进程**
定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；

注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。

5. **异步http请求线程**
XMLHttpRequest连接后通过浏览器新开一个线程请求；
检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；
